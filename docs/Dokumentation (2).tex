\documentclass[11pt, a4paper]{article}

% --- PACKAGES ---

\usepackage[utf8]{inputenc}    % Für Umlaute und Sonderzeichen
\usepackage[T1]{fontenc}       % Für korrekte Silbentrennung
\usepackage[ngerman]{babel}    % Deutsche Silbentrennung und Benennungen
\usepackage{amsmath}           % Mathematische Umgebungen (optional)
\usepackage{graphicx}          % Für Bilder
\usepackage{hyperref}          % Für klickbare Links und Inhaltsverzeichnis
\usepackage{enumitem}          % Für bessere Listenformatierung
\usepackage{fancyhdr}          % Für Kopf- und Fußzeilen
\usepackage{lastpage}          % Für Gesamtseitenzahl
\usepackage[left=2.5cm, right=2.5cm, top=3cm, bottom=3cm]{geometry} % Seitenränder
\usepackage{titlesec}          % Für individuelle Abschnittsformatierung (optional)
\usepackage{xcolor}            % Für Farben (optional)
\usepackage{lipsum}            % Für Dummy-Text (zum Befüllen)
\usepackage{caption}           % Für Bildunterschriften
\usepackage{float}             % Für die genaue Platzierung von Floats (z.B. [H] bei 
\usepackage{tabularx} 
\usepackage{booktabs}
\usepackage{fontawesome5} % For icons
\usepackage[hidelinks]{hyperref} % For clickable links (hidelinks removes the ugly boxes)
\usepackage{amssymb} % Für das Häkchen-Symbol \checkmark
\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{geometry}

% --- TITELSEITE ---
\title{\textbf{Projekt SWMT - eVisitenkarte uxitra GmbH\\Projektdokumentation}}

\author{Jonathan Müller, Tobias Wahl, Yannick Schilling}
\date{\today}

% --- KOPF- UND FUSSZEILE ---
\pagestyle{fancy}
\fancyhf{} % Alle Kopf- und Fußzeilenfelder leeren
\fancyhead[L]{Projekt SWMT - eVisitenkarte uxitra GmbH} % Links im Kopf
\fancyhead[R]{Projektdokumentation} % Rechts im Kopf
\fancyfoot[C]{\thepage\ von \pageref{LastPage}} % Seitenummer zentriert im Fuß
\renewcommand{\headrulewidth}{0.4pt} % Linie unter dem Kopf
\renewcommand{\footrulewidth}{0.4pt} % Linie über dem Fuß

% --- INHALTSVERZEICHNIS TIEFE ---
\setcounter{tocdepth}{3} % Nur bis Unterabschnitt im Inhaltsverzeichnis

% --- DOKUMENT BEGINN ---
\begin{document}

\maketitle 

\thispagestyle{empty} 

\newpage 
\tableofcontents 
\newpage
\listoffigures
\newpage
\listoftables
\newpage 

% --- 1. Einleitung ---
\section{Einleitung}
\label{sec:einleitung}

Diese Projektdokumentation dient als Referenz für die Konzeption, Entwicklung und das Vorgehen des Projekts eVisitenkarte für die uxitra GmbH, im Rahmen des Studienprojekts Softwaretechnik und Medieninformatik. Sie schafft ein klares Verständnis der Problemstellung, des Funktionsumfangs, der architektonischen Entscheidungen sowie der organisatorischen Aspekte.
Das Softwaresystem eVisitenkarte ermöglicht die Erstellung, Verwaltung und Gestaltung dynamischer elektronischer Visitenkarten für E-Paper-Displays. Eine intuitive Benutzeroberfläche (UI) verantwortet die Visitenkarteninhalte, welche formatiert per POST an das Display gesendet werden. Das System richtet sich an Personen und Organisationen, die ihre professionellen Kontakte digital und stets aktuell präsentieren möchten.\\

Die vorliegende Dokumentation ist in mehrere Kapitel unterteilt. Sie ist ein lebendiges Dokument und wird im Laufe des Projektfortschritts kontinuierlich aktualisiert und erweitert. Für den Aufbau und die Struktur der Dokumentation haben wir uns an verschiedenen Vorlagen und Beispielen orientiert. \\
\\
\section{Projekt Links}

\begin{itemize}
    \item \faGithub \, \href{https://github.com/Fiusa21/eVisitenkarte}{GitHub: eVisitenkarte}
    \item \faJira \, \href{https://swtm.atlassian.net/jira}{JIRA: swtm.atlassian.net}
\end{itemize}


\newpage
\section{Installations und Administrationsguide}
Ebenfalls im Repository als README.MD zu finden. (ggf. einfacher zu handhaben)
\subsection{Systemvoraussetzungen}
\begin{itemize}
    \item Node.js 20.x (oder $\ge$ 22.12.0) und npm
    \item Docker + Docker Compose
    \item Ports (Standard): Frontend 5173, Backend 3000, Keycloak 8080, Postgres 5432
    \item Optional: Git, make, pgAdmin (empfohlen)
\end{itemize}

\subsection{Projektstruktur}
\begin{itemize}
    \item \texttt{frontend/} — Vue 3 App (Vite)
    \item \texttt{backend/} — Express API + Keycloak Middleware + Postgres-Zugriff
    \item \texttt{docker-compose.yml} — Keycloak + Postgres Services
    \item \texttt{realm-export.json} — Keycloak Realm Export
    \item \texttt{backend/docs/} — Swagger Quelle (\texttt{/api-docs})
\end{itemize}

\subsection{Schnellstart (alle Services)}

\subsubsection{Infrastruktur starten}
Wechseln Sie in das Wurzelverzeichnis Ihres Projekts:
\begin{lstlisting}[language=bash]
cd /pfad/zu/deinem-projekt/root
docker compose up -d
\end{lstlisting}

\textbf{Services:} \texttt{keycloak} (8080), \texttt{keycloak-db}, \texttt{app-db} (5432 gemappt).

\textbf{WICHTIG:} Bis dies behoben ist, müssen Sie die Query innerhalb von \texttt{init.sql} manuell ausführen, um das Datenbank-Schema zu erstellen! Nutzen Sie entweder pgAdmin oder den folgenden Befehl im Projektverzeichnis (LINUX/MAC):
\begin{lstlisting}[language=bash]
cat init.sql | docker exec -i app-db -U myuser -d mydatabase
\end{lstlisting}

\subsubsection{Keycloak Realm importieren (einmalig)}
\begin{enumerate}
    \item Öffnen Sie \url{http://localhost:8080} $\rightarrow$ Login als Admin (Standard: \texttt{admin}/\texttt{admin}).
    \item Erstellen Sie den Realm aus der Datei \texttt{realm-export.json} mit dem Namen \texttt{eVisitenkarte-development}.
    \item Erstellen Sie einen Benutzer in Keycloak wie folgt:
    \begin{itemize}
        \item Gehen Sie im Menü links auf „Users“.
        \item Klicken Sie auf „Add user“ und geben Sie die gewünschten Attribute ein.
        \item Nach der Erstellung navigieren Sie in den Benutzerdetails zu „Role mapping“.
        \item Wählen Sie \texttt{default-roles-evisitenkarte-development} und klicken Sie auf „Assign role“.
        \item Ändern Sie im Pop-up den Filter auf „Filter by clients“ und wählen Sie die gewünschte Rolle (\texttt{admin}, \texttt{user} oder beide).
        \item Navigieren Sie zu „Credentials“ und legen Sie ein Passwort fest.
        \item Navigieren Sie zu „Attributes“ und setzen Sie die Attribute exakt wie folgt (Key links, Wert rechts):
        \begin{itemize}
            \item \texttt{phoneNumber}, \texttt{last name}, \texttt{first name}, \texttt{mobile number}, \texttt{street}, \texttt{company}, \texttt{title}, \texttt{region}, \texttt{postal\_code}
        \end{itemize}
    \end{itemize}
    \item Erwartete Clients im Code:
    \begin{itemize}
        \item Backend: \texttt{eVisitenkarte-backend} (bearer-only)
        \item Frontend: \texttt{eVisitenkarte-app} (public client)
    \end{itemize}
\end{enumerate}

\textbf{Hinweis:} Setzen Sie gültige Redirect-URIs/Web Origins für den Frontend-Client (z.B. \url{http://localhost:5173/*}).

\subsection{Backend (Express)}
\begin{enumerate}
    \item Abhängigkeiten installieren:
    \begin{lstlisting}[language=bash]
cd backend
npm install
    \end{lstlisting}
    \item Umgebung konfigurieren:
    \begin{lstlisting}[language=bash]
cp .env.example .env
    \end{lstlisting}
    \item Backend starten: \texttt{npm start}
\end{enumerate}

\begin{itemize}
    \item \textbf{API:} \url{http://localhost:3000/api}
    \item \textbf{Swagger:} \url{http://localhost:3000/api-docs}
    \item \textbf{CORS erlaubte Origin:} \url{http://localhost:5173}
\end{itemize}

\textbf{Keycloak Konfiguration (Backend):}
Realm: \texttt{eVisitenkarte-development}, Auth Server: \url{http://localhost:8080/}, Client: \texttt{eVisitenkarte-backend}.

\subsection{Frontend (Vue 3 + Vite)}
\begin{enumerate}
    \item Abhängigkeiten installieren: \texttt{cd frontend && npm install}
    \item Dev-Server starten: \texttt{npm run dev -- --host} (Standard: \url{http://localhost:5173})
    \item Build + Preview: \texttt{npm run build} und \texttt{npm run preview}
\end{enumerate}

\textbf{Keycloak Konfiguration (Frontend):}
In \texttt{src/services/keycloak-service.js}. Standardmäßig Realm \texttt{eVisitenkarte-development} und Client \texttt{eVisitenkarte-app}.

\subsection{Datenbank}
Bereitgestellt über \texttt{app-db} (Postgres 15). Standards (überschreibbar via \texttt{.env}):
\begin{itemize}
    \item \texttt{APP\_DB\_USER}: \texttt{myuser}
    \item \texttt{APP\_DB\_PASSWORD}: \texttt{mypassword!}
    \item \texttt{APP\_DB\_NAME}: \texttt{mydatabase}
\end{itemize}
Das Backend nutzt \texttt{PG*}-Umgebungsvariablen; stellen Sie sicher, dass diese mit dem DB-Service übereinstimmen.

\subsection{Authentifizierungs-Flow}
\begin{itemize}
    \item Das Frontend nutzt \texttt{keycloak-js}, um Token zu erhalten.
    \item Das Backend schützt Routen via \texttt{keycloak-connect}; Bearer-Token erforderlich.
    \item Beispiel-Endpunkte: \texttt{GET /api/protected}, \texttt{GET /api/user}, Layout-Management unter \texttt{/api/layout-management/...}.
\end{itemize}

\subsection{Fehlerbehebung (Troubleshooting)}
\begin{itemize}
    \item \textbf{Auth 401:} Überprüfen Sie Keycloak Realm/Clients; aktualisieren Sie \texttt{KEYCLOAK\_CONFIG.url}.
    \item \textbf{Datenbankfehler:} Stellen Sie sicher, dass die \texttt{PG*}-Variablen mit \texttt{app-db} übereinstimmen.
    \item \textbf{CORS-Probleme:} Erlaubte Origin in \texttt{backend/server.js} prüfen oder Frontend-Port anpassen.
    \item \textbf{Port-Konflikte:} Host-Port-Mappings in \texttt{docker-compose.yml} und Konfigurationen anpassen.
    \item \textbf{pgAdmin Hinweis:} Falls pgAdmin lokal auf demselben Standard-Port läuft, kann Docker keine Verbindung aufbauen. Prozesse beenden oder Ports ändern.
    \item \textbf{Netzwerk:} Stellen Sie sicher, dass Sie mit dem Geräte-WLAN verbunden sind.
    \item \textbf{Docker-Status:} In seltenen Fällen läuft der \texttt{app-db} Container nach \texttt{docker compose} nicht. Container manuell starten.
\end{itemize}
\newpage

% --- 2. Problemstellung und Zielgruppe ---
\section{Problemstellung und Zielgruppe}
\label{sec:problemstellung_zielgruppe}

Dieses Kapitel beleuchtet die Ausgangssituation und definiert die primäre Nutzerbasis. 

\subsection{Detaillierte Problemstellung}
\label{ssec:problemstellung_detail}
Die eVisitenkarte wird entwickelt, um die aktuell bestehende Herausforderung in Form von häufig nötigem Aktualisieren der Visitenkarte zu lösen. Diese Situation führt derzeit zu Papierverschwendung, Papiermüll und dadurch eventuell auftretende Verwirrung. Die Kernaspekte des Problems umfassen:

\begin{itemize}
    \item \textbf{Aspekt 1:} Hohe Kosten durch Papiermüll
    \item \textbf{Aspekt 2:} Hoher Zeitaufwand durch häufiges erneuern der Visitenkarte
    \item \textbf{Aspekt 3:} Verwirrung beim Kunden durch den eventuellen Besitz mehrerer Visitenkarten
\end{itemize}
Das Ziel ist es, durch die Implementierung der eVisitenkarte eine signifikante Verbesserung in diesen Bereichen zu erzielen.

\subsection{Definition der Zielgruppe}
\label{ssec:zielgruppe}
Die eVisitenkarte ist primär für folgende Zielgruppen konzipiert:
\begin{itemize}
    \item \textbf{Primäre Benutzer:} Unternehmen benötigen das System, um weniger Geld und Zeitaufwand zu verwenden um ihre Infos an Kunden und interessierte weiterzugeben.

    \item \textbf{Sekundäre Benutzer:} Auch selbstständige Businesspersonen können durch das System profitieren, da es viele sonst aufwendigen Aufgaben vereinfacht und automatisiert.

\end{itemize}
Für jede dieser Zielgruppen wurden spezifische Bedürfnisse und Erwartungen identifiziert, die im weiteren Verlauf der Anforderungsanalyse berücksichtigt werden.

\newpage

% --- 3. Geforderter Funktionsumfang ---
\section{Geforderter Funktionsumfang}
\label{sec:funktionsumfang}

Dieses Kapitel beschreibt den gefordeten Funktionsumfangs, abgeleitet aus den Anforderungen der definierten Zielgruppen und der Problemstellung, wie sie von der uxitra GmbH vorab kommuniziert wurde. Es gliedert sich in Hauptmodule und deren spezifische Funktionalitäten.

\subsection{Funktionale Anforderungen}
\begin{itemize}
    \item Die Daten wie Vor- und Zuname des Benutzers und Job-Titel sollen aus einem Identity and Access Management (IAM) System kommen (z.B. Keycloak).
    \item Ein Admin soll verschiedene Layouts erstellen können aus denen ein User auswählen kann.
    \item Ein Layout soll aus verschiedenen Elementen bestehen können (Text, Bild, QR-Code).
    \item Eine Vorschau des Layouts für den Admin soll mit Musterdaten angezeigt werden (z.B. Dr.Ing. Max Mustermann, Senior Software Developer).
    \item Ein Benutzer soll ein Layout auswählen können, eine Vorschau mit seinen befüllten Daten sehen können und diese auf die Visitenkarte schreiben können.
    \item Text Elemente sollen dabei verschiedenen Datenfeldern aus dem IAM System zugeordnet werden können, z.B. Job-Titel, Vorname, Nachname, Titel.
\end{itemize}

\subsection{User-Stories}
Aus den o.g. Anforderungen ergeben sich folgende User-Stories:\\
\textbf{User}
\begin{itemize}
\item Als User möchte ich mich ins System einloggen können um es zu nutzen
\begin{itemize}
\item Login Funktion ist implementiert
\item Login mit falschen Benutzernamen/Passwort liefert Fehlermeldung
\item Login mit richtigen Daten gewährt Zugriff auf System
\end{itemize}
Schätzung 30h
\item Als User möchte ich meine Daten einsehen können um zu erschließen welche Daten dem Kunden übermittelt werden
\begin{itemize}
\item Nutzerdaten sind in Datenbank gespeichert
\item Nutzerdaten können im UI eingesehen werden
\end{itemize}
Schätzung 10h
\item Als User möchte ich mehrere gespeicherte Layouts sehen können um meine eVisitenkarte individueller zu gestalten
\begin{itemize}
\item Layouts sind in der Datenbank gespeichert
\item Verfügbare Layouts sind in der UI einsehbar und auswählbar
\end{itemize}
Schätzung 10h
\item Als User möchte ich ein gewähltes Layout an das Display senden können um dem Kunden die Möglichkeit zu geben seine eVisitenkarte zu aktualisieren
\begin{itemize}
\item Nutzer können durch Knopfdruck ein gewähltes Layout an den Raspberry Pi senden
\item Ein angeschlossener Raspberry Pi empfängt die Nutzerdaten im gewählten Layout
\item Das Layout soll als PNG im Format 296x128px gesendet werden
\end{itemize}
Schätzung 10h
\item Als User möchte ich dass andere Nutzer meine Daten nicht einsehen können um Datenschutz zu gewährleisten
\begin{itemize}
\item User haben keinen Zugriff auf Daten anderer Nutzer
\end{itemize}
Schätzung 5h
\item Als User möchte ich Zugriff auf einen Support haben um mich bei Problemen an einen Admin zu wenden
\begin{itemize}
\item User kann in der Applikation eine Nachricht an einen Admin verfassen
\item Nachricht wird im System verwaltet und dem Admin zukommen lassen
\end{itemize}
Schätzung 20h
\end{itemize}

\textbf{Admin}
\begin{itemize}
\item Als Admin möchte ich mich ins System einloggen können um es zu nutzen
\begin{itemize}
\item Login Funktion ist implementiert
\item Login mit falschen Benutzernamen/Passwort liefert Fehlermeldung
\item Login mit richtigen Daten gewährt Zugriff auf System
\end{itemize}
Schätzung 5h
\item Als Admin möchte ich zwischen Admin und Usermodus wechseln können um das System mit einem Konto als User als auch als Admin nutzen zu können
\begin{itemize}
\item Das System unterscheidet zwischen normalen Usern und Admins, die Rolle ist in einer Datenbank hinterlegt
\item Im Frontend ist ein für normale User versteckter Slider hinterlegt der das System in den Admin Modus bzw. zurück in den User Modus versetzt
\item Der Admin erhält im User Modus alle Funktionen die ein normaler User hat
\end{itemize}
Schätzung 10h
\item Als Admin möchte ich verschiedene Layouts erstellen können die dem Nutzer zur Auswahl gegeben werden um Kontrolle über die Art und Weise zu haben wie Firmendaten dem Kunden angezeigt werden
\begin{itemize}
\item Ein Layouteditor ist implementiert
\item Neue Layouts können erstellt werden
\item Erstellte Layouts werden in einer Datenbank gespeichert
\item Erstellte Layouts werden den Usern angezeigt
\end{itemize}
Schätzung 30h
\item Als Admin möchte ich verschiedene Elemente wie Text (Name, Titel, Firmenadresse), sowie Bilder und QR Codes in ein Layout einfügen können um dem User die Möglichkeit zu bieten seine Daten vollständig präsentieren zu können
\begin{itemize}
\item Der Layouteditor stellt verschiedene Tools bereit mit denen sich Elemente auf ein Layout einfügen lassen
\item Die Visitenkarte ist stets im Format 296x128
\end{itemize}
Schätzung 30h
\item Als Admin möchte ich eine Vorschau meiner Layouts mit Musterdaten angezeigt bekommen um mir die kreierten Daten besser vorstellen zu können
\begin{itemize}
\item Gespeicherte Layouts werden mit Musterdaten angezeigt
\item Musterdaten werden schon im Editor angezeigt
\end{itemize}
Schätzung 5h
\item Als Admin möchte ich gespeicherte Layouts löschen und bearbeiten können um nach dem ersten Abspeichern nicht den Zugriff auf sie zu verlieren
\begin{itemize}
\item Wird im Adminmodus ein gespeichertes Layout gewählt so erscheinen Buttons die das Bearbeiten bzw. Löschen des Layouts ermöglichen
\end{itemize}
Schätzung 5h
\item Als Admin möchte ich Userkonten einsehen können um diese auf Richtigkeit zu überprüfen
\begin{itemize}
\item Admins erhalten Zugriff auf eine Nutzerverwaltung
\item Admins bekommen die Daten aller Nutzer angezeigt
\end{itemize}
Schätzung 5h
\item Als Admin möchte ich nach bestimmten Usern suchen können um bei großer Nutzeranzahl schnell auf bestimmte Daten zugreifen zu können
\begin{itemize}
\item In der Nutzerverwaltung ist eine Suchleiste hinterlegt
\item Die Suche erfolgt über den Namen des Nutzers
\item Die Suche liefert alle Nutzer deren Namen den gesuchten Namen enthält
\end{itemize}
Schätzung 20h
\end{itemize}

\textbf{Anforderungen}
\begin{itemize}
\item Es gibt einen Systemadmin der Nutzer über eine Config Datei zum Admin machen kann
Schätzung 10h
\item Benutzerdaten sollen aus IAM System geladen werden
Schätzung 20h
\item Benutzerdaten beinhalten Vor- und Nachname sowie Jobtitel des Benutzers, aber auch Benutzername und Passwort sollen im IAM System hinterlegt werden
Schätzung 10h
\item Manche Benutzerdaten sollen Pflichtfelder sein (Vor/Nachname, ...), manche optional (QR Code). Das gilt sowohl für die Kontenanlegung im Backend als auch beim Elemente einfügen auf das Layout
Schätzung 10h
\end{itemize}







\textbf{Aktuell befinden sich noch weitere Features und Funktionen in der Ausarbeitungsphase, welche zu einem späteren Zeitpunkt final festgelegt werden.}\\
Einige Ideen sind:

\begin{itemize}
\item QR-Code Generierung um vom ePaper Display digitale Visitenkarten bzw. Kontaktdaten direkt in einem Smartphone zu speichern (vCard).

\item QR-Code Generierung um direkt auf die Website des Erstellers zu kommen


\end{itemize}

\subsection{Hauptmodule und deren Kernfunktionen}
\label{ssec:hauptmodule}
Das System wird folgende Hauptmodule umfassen:
\begin{enumerate}
    \item \textbf{Modul A: Benutzerverwaltung}
    \begin{description}
        \item Funktion A.1, Authentifizierung.
        \item Funktion A.2, Autorisierung von Zugriffen auf Backend und Daten 
    \end{description}

    \item \textbf{Modul B: Datenmanagement}
    \begin{description}
        \item Funktion B.1, Daten-CRUD für Visitenkartendaten/Layouts über Services und Datenbank 
        \item Funktion B.2, Bereitstellung von Visitenkartendaten für das ePaper-Display
        \item Funktion B.3, Speicherung von erstellten Visitenkarten
    \end{description}

    \item \textbf{Modul C: Generierung \& Bereitstellung}
    \begin{description}
        \item Funktion C.1, Generierung von Visitenkarten auf Basis entsprechender Anfragen
        \item Funktion C.2, Bereitstellung der generierten Bilder für Frontend über Backend
        \item Funktion C.2, Umwandlung der Visitenkarten für das ePaper-Display
    \end{description}

    \item \textbf{Modul D: Hardware-Interaktionen}
    \begin{description}
        \item Funktion D.1, Schnitstelle zur Kommunikation mit ePaper-Display 
        \item Funktion D.2, Senden der Visitenkarte an das ePaper-Display 
    \end{description}
    
\end{enumerate}

\subsection{Nicht-funktionale Anforderungen}
\label{ssec:nicht_funktionale_anforderungen}
Neben den Kernfunktionen ergeben sich vorab folgende nicht-funktionale Anforderungen:
\begin{itemize}
    \item \textbf{Usability:} Die Benutzeroberfläche muss intuitiv bedienbar sein und eine Einarbeitungszeit von maximal 1h erfordern.
    \item \textbf{Wartbarkeit:} Die Codebasis muss klar strukturiert und gut dokumentiert sein, um eine einfache Wartung und Erweiterung zu ermöglichen.
    \item \textbf{Plattformunabghängigkeit:} Die Software soll unabhängig vom Betriebssystem des Nutzers lauffähig sein.


\end{itemize}

\newpage
\section{Implementierte Features}


\begin{description}

    \item[Keycloak Integration] Automatischer Abruf von Benutzerstammdaten (z.\,B. Vor- und Zuname) aus dem Identity and Access Management System.
    \item[Layout-Verwaltung] Zentrale Erstellung und Administration verschiedener Design-Vorlagen für Endnutzer.
    \item[Modulares Design] Flexibler Aufbau von Layouts durch die Kombination von Text-, Bild- und QR-Code-Elementen.
    \item[Mock-Data Preview] Administrative Vorschaufunktion der Layouts unter Verwendung von Musterdaten zur Qualitätssicherung.
    \item[E-Paper Transfer] Benutzergesteuerte Auswahl und direkte Übermittlung von Layout-Daten an E-Paper-Displays.

     \item[Connectivity-Indicator] Echtzeit-Statusanzeige der Verbindung zum ePaper-Device.
    \item[Modal-Ansicht] Overlay-Fenster zur Vorschau von Karten.
    \item[Admin-Slider] UI-Komponente zum schnellen Wechsel zwischen Admin und User Modus.
    \item[Property-Editor] Modul zur detaillierten Bearbeitung von Objekteigenschaften.
    \item[Tool-Box] Zentrale Sammlung von Werkzeugen.
    \item[QR-Generator] Automatisierte Erstellung von QR-Codes aus URLs.
    \item[Preview-PNG-Download] Export-Funktion für Layout-Vorschauen im PNG-Format.
\end{description}


\newpage
% --- 4. UI Entwürfe ---
\section{UI Designs}
\label{sec:ui_entwuerfe}

Dieses Kapitel präsentiert Konzepte und erste Sketches der Benutzeroberfläche. Die Entwürfe dienen als visuelle Leitlinie für die Implementierung und sollen ein klares Bild der Benutzerinteraktion und des Layouts vermitteln. Sie basieren auf den identifizierten Anforderungen und Usability-Prinzipien. Die Anwendung ist primär als Desktop-Webanwendung für gängige Webbrowser konzipiert.

\subsection{Ziel}
Ziel der erstellten Sketches ist es, das geplante Layout und die grundlegende Benutzerführung der Anwendung konzeptionell zu visualisieren. Die Entwürfe dienen als Grundlage für spätere Prototypen und Implementierungen.

\subsection{Übersicht}
Die Anwendung gliedert sich in mehrere zentrale Ansichten, die über ein einheitliches Navigationsmenü erreichbar sind. Durch das klare und minimalistische Design, soll eine intuitive Benutzerführung gewährleistet werden. Alle Ansichten folgen demselben Aufbau, wodurch sich sowohl Endnutzer als auch Administratoren schnell zurechtfinden können.


\subsection{Wireframes und Mockups ausgewählter Oberflächen}
\label{ssec:wireframes_mockups}
In diesem Abschnitt werden die einzelnen Ansichten vorgestellt und erläutert. Jeder Entwurf dient dazu, den geplanten Aufbau, die Navigation und die Funktionsweise der Benutzeroberfläche konzeptionell zu visualisieren. Ziel der Entwürfe war es, vor der eigentlichen Implementierung eine klares Verständnis für die Struktur und den Navigationsablauf der Benutzeroberfläche zu gewinnen.



\subsubsection{Login-Seite}
Die Login-Seite, wie in Abb. 1 zu sehen ist, bildet den Einstiegspunk der Anwendung. In der Entwurfsphase wurde ein infacher Anmeldebildschirm gestaltet, über den sich der Nutzer mit E-Mail und Passwort anmelden können. Zusätzlich wurde über einen Link nachgedacht, der bei Vergessen oder Verlust des eigenen Passwortes eine Verbindung zum Admin herstellt, um eine Zurücksetzung zu beantragen. 
Nach Abschluss der Entwurfsphase wurde entschieden, die Authentifizierung über das externe System Keycloak zu realisieren. Dadurch entfällt die manuelle Implementierung des Login-Prozesses. Der erstellte Sketch dient somit als Konzeptionelle Grundlage und half, das Erscheinungsbild und die Benutzerführung des später durch Keycloak bereitgestellten Login-Dialogs frühzeitig zu planen und zu visualisieren. Dennoch ist die Darstellung hier unbedingt erforderlich, da der Login der Einstiegspunkt und somit essenziell für das Verständnis der Abläufe ist.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{login.png} 
    \caption{UI Entwurf: Login-Seite}
    \label{fig:ui_login}
\end{figure}



\subsubsection{Hauptseite}
Die Hauptseite stellt die zentrale Übersicht der Anwendung dar und dient als Ausgangspunkt für alle weiteren Funktionen. Nach erfolgreicher Anmeldung gelangt der Nutzer standardmäßig auf diese Ansicht. Sie besteht aus einer klar gegliederten Navigation mit Reitern „Daten“ und „Layouts“, über die zwischen den Hauptfunktionen der Anwendung gewechselt werden kann, wie in Abb. 2 zu sehen ist.
Im Benutzermodus werden ausschließlich persönliche Informationen angezeigt. Im Reiter „Daten“, der standardmäßig aufgerufen wird nach dem Einloggen, kann der Nutzer eigene Angaben wie Name, Titel, Adresse, Telefonnummer oder E-Mail-Adresse einsehen. Diese Informationen bilden die Grundlage für die spätere Erstellung der eVisitenkarte. \\

Administratoren verfügen über denselben Aufbau, können jedoch über einen Adminmodus-Schalter in der Kopfzeile, siehe Abb. 3, zwischen Benutzer- und Administratoransicht wechseln. Wird der Schalter aktiviert, erscheint im Navigationsbereich ein zusätzlicher Reiter mit „Nutzer“, der für reguläre Benutzer ausgeblendet bleibt. Die übrigen Funktionen, wie die Einsicht der eigenen Daten und Layouts bleiben auch im Adminmodus unverändert, wodurch die Bedienlogik konsistent bleibt.  \\

Durch dieses Konzept wird eine rollenbasierte Benutzeroberfläche geschaffen, die mit einem einzigen Interface sowohl einfache Nutzerinteraktionen als auch administrative Aufgaben unterstützt. Der Wechsel zwischen den Modi erfolgt ohne Kontextwechsel, was die Übersichtlichkeit erhöht, und die Wartung vereinfacht.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{home} 
    \caption{UI Entwurf: Hauptseite}
    \label{fig:ui_dashboard}
\end{figure}



\subsubsection{Nutzerverwaltung}
Die Nutzerverwaltung steht ausschließlich Administratoren zur Verfügung und dient der Verwaltung aller im System registrierten Benutzer. In diesem Bereich erhält der Administrator Zugriff auf eine Liste aller registrierten Mitarbeiter und kann einzelne Datensätze auswählen, bearbeiten, hinzufügen oder löschen wie in Abb. 3 zu sehen ist. Wird ein Eintrag ausgewählt oder neu angelegt, öffnet sich die Bearbeitungsansicht, siehe Abb. 4, in der alle zugehörigen Felder editiert werden können. Diese Eingabemaske orientiert sich am Aufbau der Benutzeransicht und ermöglicht dem Administrator, dieselben Datenfelder wie ein regulärer Nutzer anzupassen – jedoch mit erweiterten Rechten, um auch fremde Konten zu ändern oder zu deaktivieren. Zum aktuellen Zeitpunkt ist noch nicht final geklärt ob eine Nutzerverwaltung implementiert werden muss oder ob, wie bereits in vorherigen Abschnitten erwähnt, die in Keycloak eingebettete Nutzerverwaltung genutzt wird. In diesem Fall würde die Nutzerverwaltung extern erfolgen und nicht mit in die UI integriert werden.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{user.png} 
    \caption{UI Entwurf: Nutzerverwaltung}
    \label{fig:ui_users}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{userdit.png} 
    \caption{UI Entwurf: Nutzerbearbeitung}
    \label{fig:ui_useredit}
\end{figure}

\subsubsection{Layout Erstellung und Bearbeitung}
Administratoren haben in der Anwendung die Möglichkeit, neue Layouts für die eVisitenkarten zu erstellen oder bestehende Vorlagen zu bearbeiten. Diese Funktion ist über den Reiter „Layouts“ im Adminmodus zugänglich und erweitert die Layoutansicht der Benutzer um zusätzliche Bearbeitungsoptionen. Die Layout-Übersicht zeigt alle vorhandenen Designvorlagen in einer strukturierten Kachelansicht (siehe Abb. 5). Wird nun auf eines dieser Layouts gedrückt, so öffnet sich ein Popup das eine Vorschau des Layouts mit den eigenen Daten ermöglicht (siehe Abb. 6). Hier hat der Administrator die Möglichkeit das ausgewählte Layout zu bearbeiten oder es zu löschen. Wird ein Layout zur Bearbeitung geöffnet, wie in Abb. 7 zu sehen, wechselt die Anwendung in die Layout-Editor-Ansicht. Dort können zentrale Eigenschaften wie Farben, Schriftgrößen, Platzhalter für Textelemente oder die Positionierung von Logos angepasst werden. Der Editor ist so konzipiert, dass Änderungen unmittelbar in einer Vorschau sichtbar werden. Durch diesen Ansatz können Administratoren Layouts effizient an individuelle Anforderungen anpassen. Hierbei soll auch darauf geachtet werden, dass eingefügte Bilder oder Texte eine bestimmte Größe nicht übersteigen. Diese Begrenzungen sorgen für eine klare Wiedergabe auf der eVisitenkarte.
Der Bearbeitungsprozess ist bewusst einfach gehalten, um auch ohne tiefgehende Designkenntnisse nutzbar zu sein. Gleichzeitig stellt das konsistente Interface sicher, dass neue Layouts visuell mit bestehenden Vorlagen harmonieren. Änderungen werden erst nach expliziter Bestätigung gespeichert, um unbeabsichtigte Anpassungen zu vermeiden.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{layoutadmin.png} 
    \caption{UI Entwurf: Layouts}
    \label{fig:ui_layoutadmin}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{editadmin.png} 
    \caption{UI Entwurf: Layoutbearbeitung}
    \label{fig:ui_editadmin}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{editadmin2.png} 
    \caption{UI Entwurf: Layoutbearbeitung 2}
    \label{fig:ui_editadmin2}
\end{figure}



\subsubsection{Layout Auswahl durch Nutzer}
Für reguläre Nutzer steht im Reiter „Layouts“ die Auswahl und Verwaltung der verfügbaren Visitenkarten-Designs im Vordergrund. Nach dem Login und Aufruf des Home-Screens kann der Nutzer in dieser Ansicht aus verschiedenen, zuvor von Administratoren angelegten Layouts wählen (siehe Abb. 8). Die Layouts werden in einer übersichtlichen Kachel- oder Listenansicht dargestellt. Durch Anklicken eines Layouts öffnet sich eine Detailansicht, in der das gewählte Design in eVisitenkarten Darstellung und Dimensionen angezeigt wird. Dort kann der Nutzer, die zuvor unter „Daten“ einsehbaren Informationen, in dem Layout wiederfinden (siehe Abb. 9).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{selection.png} 
    \caption{UI Entwurf: Layout-Asuwahl}
    \label{fig:ui_selection}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{fina.png} 
    \caption{UI Entwurf: Layout senden}
    \label{fig:ui_selection}
\end{figure}

\subsection{Zusammenfassung und Ausblick}
Im nächsten Schritt soll auf Grundlage der erstellten Wireframes ein interaktiver Prototyp mit einem finalen Farbschema und detaillierteren grafischen Elementen entwickelt werden. Ziel ist es, die Benutzerführung und das Design realitätsnäher darzustellen. Zusätzlich ist die Erstellung eines Clickdummys geplant, um die Navigation zwischen den einzelnen Seiten zu simulieren und erste Usability-Tests durchführen zu können.

\newpage

\subsection{Figma Prototyp/Clickdummy}

Zur Gestaltung des Clickdummys wurden die bereits vorhandenen UI-Sketches in Absprache mit dem Kunden angepasst. Der Clickdummy soll nun nicht nur das Layout, sondern auch die Interaktivität der Anwendung darstellen und simulieren, um somit eine Präsentation der Ideen verständlicher zu machen und klare Richtlinien für die Implementierung zu schaffen.
Zur Erstellung des Clickdummys wurde Figma verwendet, da die Anwendung alle für das Projekt benötigten Funktionen bereitstellt und dem Entwicklerteam bereits vertraut war.
Im Folgenden wird auf visuelle Ergänzungen/Abänderungen von den UI-Sketches eingegangen.


\subsubsection{Hauptseite (User Home)}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{homefig.jpg} 
    \caption{User-Home}
    \label{fig:ui_selection}
\end{figure}
Wie in Abb. 10 zu sehen wurde der Clickdummy farbig gestaltet. Die Farbgebung wurde an die Farben der Firma Uxitra angepasst und soll auch für die Implementierung beibehalten werden. 
Die Nutzeransicht wurde auf einen Bildschirm komprimiert, um dem Nutzer die Navigation über die Anwendung zu erleichtern. Auf der linken Seite des Bildschirms befinden sich die für den Nutzer relevanten Nutzerdaten, rechts daneben die Layouts. Die Nutzeroberfläche ist aufgrund des relativ geringen Funktionsumfangs weiterhin sehr intuitiv und übersichtlich. Um zu verdeutlichen, dass Layouts klickbare Elemente sind, werden diese leicht vergrößert, wenn der Nutzer mit der Maus darüber schwebt. Bei einem Klick auf ein Layout öffnet sich ein Pop-up, welches das Layout vergrößert anzeigt und die Option bietet dieses als .png an das ePaper zu senden. Dieses Pop-up ist in Abb. 11 zu sehen. Der Admin Modus ist weiterhin über einen Schieberegler zu erreichen, der sich nun im linken oberen App befindet und für Nutzer ohne Admin Zugriff ausgeblendet wird. 
Zudem lässt sich nun eine Hilfe-Funktion über den Button mit der Glocke oben rechts erreichen, die in den Anforderungen näher erläutert wird. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{popup.jpg} 
    \caption{Layout-Popup}
    \label{fig:ui_selection}
\end{figure}

\subsubsection{Hauptseite (Admin Home)}
Im Admin Modus (Abb. 12) bleibt das User-Layout weitgehend erhalten, um Verwirrung zu vermeiden. Die Userdaten verschwinden, da der angemeldete Admin nun in seiner Admin-Funktion handelt und nicht mehr als Nutzer. Hinzu kommt eine Navigationsleiste am oberen Bildschirmrand, die den aktiven Reiter “Home” und den Reiter “Nutzer” anzeigt. Zudem erscheint ein leeres Layout mit einem “+”, welches den Admin mit einem Klick zum Layout-Editor führt. Das Pop-up zeigt nun, bei Klick auf ein bereits existierendes Layout, “löschen” und eine “bearbeiten” Funktion.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{adminfig.jpg} 
    \caption{Admin-Home}
    \label{fig:ui_selection}
\end{figure}

\subsubsection{Layout-Editor}
Der Layout-Editor ist nur im Admin Modus verfügbar. Er zeigt das aktuell bearbeitete Layout mit allen bisherigen Elementen oder im Falle von Abb. 13 ein neues, leeres Layout. Dieses kann über den “Speichern” Button gespeichert werden, welcher den Layout-Editor bei einem Klick auch schließt. Links neben dem angezeigten Layout ist eine Toolbar, welche den Nutzer verschiedene Elemente zum Layout hinzufügen lässt. Darunter sind Textelemente die zu Attributen aus den Nutzerdaten gemappt werden, sowie geometrische Formen. Alle Elemente sind in schwarz/weiß verfügbar, da das ePaper sowieso nur schwarz/weiß Bilder anzeigt. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{layoutfig.jpg} 
    \caption{Layout-Editor}
    \label{fig:ui_selection}
\end{figure}

\subsubsection{Nutzerverwaltung}
Mit dem Reiter “Nutzer” navigiert der Admin auf die Nutzerverwaltung. Dort sind links in einer scrollbaren Liste alle Mitarbeiter angezeigt. Diese können auch durch Eingabe ihrer im System vermerkten Namen im Suchfeld einzeln herausgefiltert werden. Die rechte Seite des Bildschirms wird von den Nutzerdaten des aktuell ausgewählten Nutzers ausgefüllt. Hier ist auch das Profilbild des Nutzers zu sehen. Der Admin erhält die Option den Nutzer zu bearbeiten sowie ihn aus der Datenbank zu löschen. Falls er den Nutzer löschen möchte, wird er von einem Pop-up aufgefordert, die Aktion zu bestätigen, um ein versehentliches Löschen zu vermeiden. Wenn, wie in Abb. 14 kein Nutzer ausgewählt ist, werden leere Felder angezeigt. Wenn diese vom Admin ausgefüllt werden, kann er einen neuen Nutzer zum System hinzufügen.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{userfig.jpg} 
    \caption{Nutzerverwaltung}
    \label{fig:ui_selection}
\end{figure}

\subsection{Finales Design}
Nachdem die grundlegenden Anforderungen in den Wireframes (Kapitel 7.3) konzeptionell erarbeitet und im Figma-Prototyp (Kapitel 7.5) visuell sowie interaktiv verfeinert wurden, erfolgte die technische Umsetzung der Nutzeroberfläche. In diesem Abschnitt wird die finale Implementierung der Anwendung präsentiert. Dabei wurde das Ziel verfolgt, ein konsistentes und intuitives Design zu schaffen, das eine effiziente Verwaltung der eVisitenkarten ermöglicht. Die folgenden Unterkapitel zeigen die tatsächlichen Screens der Webanwendung und erläutern die funktionalen Details sowie die finale Nutzerführung im Live-System.

\subsubsection{Login Seite}
Wie in Abbildung 15 zu sehen ist, wurde die Anwendung um eine dedizierte Login-Seite ergänzt, die als zentraler Einstiegspunkt dient. Im Gegensatz zu den ersten Entwürfen wurde hier aus Sicherheitsgründen eine strikte Trennung zwischen der Landingpage und dem Authentifizierungsprozess implementiert. Durch Betätigen des Anmeldebuttons wird der Nutzer sicher zur Keycloak-Authentifizierung (Abb. 16) weitergeleitet.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{Login_final.png} 
    \caption{Landing Page}
    \label{fig:ui_selection}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{Login_fields_final.png} 
    \caption{Login}
    \label{fig:ui_selection}
\end{figure}

Diese Integration garantiert eine DSGVO-konforme Identitätsverwaltung und ermöglicht ein Single-Sign-On-Erlebnis, das über die rein grafische Planung im Figma-Prototyp hinausgeht.

\subsection{Nutzer-Homepage}
Nach erfolgreichem Login wird der Nutzer auf die „User Home“-Seite geleitet (Abb. 17). Das finale Design hält sich eng an die Vorgaben aus dem interaktiven Prototyp, wurde jedoch im Hinblick auf die Übersichtlichkeit optimiert. Der Nutzer findet hier eine komprimierte Ansicht seiner persönlichen Daten sowie eine Galerie der verfügbaren Layouts. Die Kachel-Optik der Visitenkarten wurde übernommen, um eine konsistente User Experience zwischen dem Design-Konzept und der fertigen Webanwendung zu gewährleisten.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{user_home_final.png} 
    \caption{User-Home}
    \label{fig:ui_selection}
\end{figure}

In der Layout-Übersicht (Abb. 17) kann der Nutzer durch die verfügbaren Designs navigieren. Ein funktionaler Mehrwert der fertigen Anwendung ist die Detail- und Vorschaufunktion (Abb. 18). Hier wurde die Interaktivität im Vergleich zum Prototyp dahingehend erweitert, dass der Nutzer eine vergrößerte Live-Vorschau erhält, bevor er den Prozess zum Senden des Layouts an das ePaper-Display (Abb. 18) initiiert. Dies minimiert Fehlübertragungen und erhöht die Benutzerfreundlichkeit.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{modal_final.png} 
    \caption{User Overlay}
    \label{fig:ui_selection}
\end{figure}

\subsection{Admin-Homepage}
Die Admin Homepage, siehe Abb. 19, unterscheidet sich nur geringfügig von dem zuvor gezeigten Figma Prototypen. Einzig die Funktion die Anzeigt ob ein ePaper verbunden ist wurde ergänzt.  

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{admin_home_final.png} 
    \caption{Admin-Home}
    \label{fig:ui_selection}
\end{figure}

Auch hier kann wieder durch Klicken auf eines der Layouts eine genauere Untersuchung der Visitenkarte ermöglicht werden. Der Admin hat hier die Möglichkeit das ausgewählte Layout zu Bearbeiten oder es direkt und unwiderruflich zu löschen. 
Wie bereits im Figma Prototypen gezeigt kann der Admin durch anklicken des leeren Layouts mit dem „+“ ein neues Layout hinzufügen. Hierbei wird er auf den Layout Editor weitergeleitet. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{admin_modal_final.png} 
    \caption{Admin Overlay}
    \label{fig:ui_selection}
\end{figure}
\subsection{Layout Editor}

Der Editor stellt das Herzstück der administrativen Oberfläche dar. Bevor der Admin ein neues Layout bearbeiten kann, wird er nun aufgefordert einen Namen für das Layout zu vergeben (Abb. 21). In diesem Schritt wird das Layout mit Namen in der Datenbank gespeichert und direkt mit einer ID versehen.  

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{editor_final.png} 
    \caption{Editor}
    \label{fig:ui_selection}
\end{figure}

Nach vergabe des Namens kann der Admin nun mit der Bearbeitung beginnen, siehe Abb. 22. Hier wurde der Layout Editor im Vergleich zum Figma Prototypen um verschiedene Funktionen erweitert. Über die „ToolBox“ (Abb. 22–25) können Textfelder, Formen und Logos flexibel auf dem Canvas platziert werden. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{properties_final.png} 
    \caption{Textfelder}
    \label{fig:ui_selection}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{forms_final.png} 
    \caption{Formen}
    \label{fig:ui_selection}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{media_final.png} 
    \caption{Logos}
    \label{fig:ui_selection}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{qr_final.png} 
    \caption{QR-Generator}
    \label{fig:ui_selection}
\end{figure}

Eine wesentliche technische Erweiterung gegenüber den Figma-Entwürfen ist der PropertyEditor (Abb. 26). Dieser erlaubt nicht nur die präzise Positionierung und Skalierung von Elementen, sondern beinhaltet auch eine intelligente Kontrastlogik: Ändert der Administrator die Hintergrundfarbe des Layouts, passt das System automatisch den Kontrast der darauf befindlichen Elemente an. Dies stellt sicher, dass die Visitenkarten auf den ePaper-Displays jederzeit optimal lesbar bleiben – ein Detail, das im statischen Design-Entwurf noch nicht berücksichtigt war.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.3\textwidth]{info_final.png} 
    \caption{Landing Page}
    \label{fig:ui_selection}
\end{figure}

\subsection{Nutzerverwaltung}

In der finalen Umsetzung wurde die Nutzerverwaltung (Abb. 27) effizienter gestaltet als ursprünglich im Figma-Prototyp geplant. Anstatt eine eigene, redundante Oberfläche zu entwickeln, wird der Administrator direkt in die Keycloak-Verwaltungsumgebung geleitet. Dies bietet den Vorteil, dass alle administrativen Aufgaben (Hinzufügen, Bearbeiten oder Löschen von Nutzern) in einer hochsicheren und standardisierten Umgebung stattfinden. Dieser Ansatz reduziert die Fehleranfälligkeit und den Wartungsaufwand des Gesamtsystems erheblich, während der volle Funktionsumfang der geplanten Nutzerverwaltung erhalten bleibt.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{useredit_final.png} 
    \caption{Nutzerverwaltung Keycloak}
    \label{fig:ui_selection}
\end{figure}




% --- 5. Architektur (konzeptionell + technologisch) ---
\section{Architektur (konzeptionell und technologisch)}
\label{sec:architektur}

Dieses Kapitel soll einen Überblick zur Architektur geben, wobei sowohl konzeptionelle Modelle als auch die zugrunde liegenden technologischen Entscheidungen detailliert werden. Aus den Gegebenheiten, Gesprächen mit Herrn Michael Watzko und Herrn Alexander Pärsch, sowie der Bereitstellung des Raspberry-Pi Prototyps durch die uxitra GmbH, erschließt sich das folgende Konzept und ist das für uns Naheliegendste. Ein weiterer äußerst wichtiger Aspekt für uns bei der Entscheidung war, der zum Einen sehr begrenzte Zeitraum als auch die geringe Manpower. Auf diesem Hintergrund haben wir uns für die im folgenden beschriebnen Prinzipien und Designziele entschieden.

\subsection{Architekturprinzipien und Designziele}
\label{ssec:arch_prinzipien}
Die Architekturgestaltung basiert auf folgenden Leitprinzipien:
\begin{itemize}
    \item \textbf{Modulare Bauweise:} Reduzierung der Komplexität durch Zerlegung in unabhängige, wiederverwendbare Komponenten und zur Parallelisierung der Entwicklung, sowohl in Bezug auf Implementierung als auch Konzeption, Design und Planung.
    \item \textbf{Schichtenarchitektur:} Klare Trennung von Belangen zur Förderung von Wartbarkeit, Erweiterbarkeit und Nachvollziehbarkeit.
    \item \textbf{Plattformunabhängigkeit:} Die Anwendnung kann auf die verschiedenen Betriebssystemen laufen, was die Wahl der Infrastruktur, Wartbarkeit, Migration und ggf. Weiterentwicklung deutlich erleichtert. 
    
\end{itemize}

\subsection{Konzeptionelle Architektur}
\label{ssec:konzeptionelle_arch}
Die konzeptionelle Architektur (Abb. \ref{fig:konzeptionell_makro_full})  beschreibt das System aus einer einfacheren Perspektive und identifiziert die Hauptkomponenten und deren Interaktionen auf einer hohen Abstraktionsebene. Diese soll ein Grundverständnis für den Aufbau und Umfang schaffen, sowie die zugrundeliegenden Prinzipien veranschaulichen.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{Architektur_konzept.png} 
    \caption{Konzeptionelle Ansicht des Gesamtsystems}
    \label{fig:konzeptionell_makro_full}
\end{figure}
Das System ist in drei Hauptschichten unterteilt: die Benutzer-/Verwaltungs-Schicht (Präsentation), die Backend-Schicht (Applikation und Domäne) und die Endgerät-Schicht (Infrastruktur).

\subsubsection{Benutzer-/Verwaltungs-Schicht (Präsentation)}
Diese Schicht ist für die Interaktion mit dem Endbenutzer verantwortlich.
\begin{itemize}
    \item \textbf{Client Webbrowser}: Der zentrale Bestandteil dieser Schicht. Er initiiert \texttt{RESTful API} Anfragen, greift auf das Frontend zu, stellt Authentifizierungsanfragen und empfängt \texttt{OAuth} Token.
    \item \textbf{Frontend Server (Optional)}: Liefert \texttt{JavaScript} basierte Frontends an den \textit{Client Webbrowser} aus.
    \item \textbf{Keycloak Identity Provider}: Verantwortlich für Authentifizierung und Sicherheit. Er verarbeitet Authentifizierungsanfragen und gibt Token zurück.
\end{itemize}

\subsubsection{Backend-Schicht (Applikation \& Domäne)}
Diese Schicht implementiert die Kernlogik des Systems.
\begin{itemize}
    \item \textbf{Backend API Server}: Fungiert als zentrale Schnittstelle im Backend. Er empfängt \texttt{RESTful API} Anfragen, interagiert mit der \textit{E-Paper Schnittstelle} und dem \textit{Visitenkarten Generierungsservice}. Er stellt zudem generierte Bilder bereit und verarbeitet Generierungsanfragen.
    \item \textbf{E-Paper Schnittstelle}: Verantwortlich für die Bereitstellung von Bildern, das Pushen aktueller Visitenkarten (\texttt{POST}) und das Zurückliefern von Visitenkartenbild(ern).
    \item \textbf{Visitenkarten Generierung Service}: Generiert Visitenkarten als Bilder (\texttt{PNG}/\texttt{Bitmap}) basierend auf Generierungsanfragen und verwaltet die für die Generierung notwendigen Daten.
\end{itemize}

\subsubsection{Endgerät-Schicht (Infrastruktur)}
Diese Schicht repräsentiert das physische Ausgabegerät.
\begin{itemize}
    \item \textbf{Raspberry Pi E-Paper Display}: Empfängt Visitenkartenbilder von der \textit{E-Paper Schnittstelle} und zeigt diese auf dem E-Paper Display an.
\end{itemize}

\subsection{Interaktionen}
Die Komponenten interagieren wie folgt:
\begin{itemize}
    \item Der \textit{Client Webbrowser} sendet Anfragen an den \textit{Backend API Server} und kommuniziert optional mit dem \textit{Frontend Server}.
    \item Authentifizierungsanfragen werden vom \textit{Client Webbrowser} an den \textit{Keycloak Identity Provider} gerichtet.
    \item Der \textit{Backend API Server} leitet Bildgenerierungsanfragen an den \textit{Visitenkarten Generierung Service} weiter und empfängt die generierten Bilder.
    \item Für die Verwaltung der E-Paper Displays interagiert der \textit{Backend API Server} mit der \textit{E-Paper Schnittstelle}, welche die Bilder an das \textit{Raspberry Pi E-Paper Display} übermittelt.
    \item Eine \textbf{Datenbank} dient als persistenter Speicher für den \textit{Backend API Server} (für \texttt{CRUD}-Operationen) und für den \textit{Visitenkarten Generierung Service} (für generierungsrelevante Daten).
    \item Das \textit{Raspberry Pi E-Paper Display} ist das Endgerät, das die finalen Visitenkarten darstellt.
\end{itemize}

\subsection{Technologien}
\label{ssec:technologische_arch}
Die Technologien die zur Umsetzung der konzeptionellen Architektur verwendet werden. Hierbei wurden zu Beginn kleinere Tests auf lokaler Ebene durchgeführt um uns mit den geplanten Technologien vertraut zu machen. Auf Basis dieser Tests haben wir uns letztendlich aufgrund folgender Faktoren für diesen Technologie-Stack entschieden.
\\

\begin{itemize}
    \item \textbf{Frontend: Vue.js} wurde gewählt, da es ein leichtgewichtiges, komponentenbasiertes Framework ist, das eine klare Trennung zwischen Logik, Struktur und Stil erlaubt. Gegenüber schwergewichtigen Alternativen (z.B. Angular) bietet es eine flachere Lernkurve und ermöglicht dennoch eine saubere Architektur.  
    \item \textbf{Backend-Services: Node.js} wurde gewählt wegen seiner besonders guten Eignung für APIs. Zudem ermöglicht JavaScript im Backend eine durchgängige Sprache im Projekt, was die Entwicklung erheblich beschleunigt.
    \item \textbf{Datenbank: PostgreSQL} ist ein stabiles, SQL-basiertes Datenbanksystem mit ACID-Compliance, umfangreicher JSON-Unterstützung und solider Performance. Es bietet mehr Flexibilität und Zuverlässigkeit als reine NoSQL-Lösungen und eignet sich gut für strukturierte Datenmodelle.
    \item \textbf{Authentifizierung: Keycloak} dient als Identity- und Access-Management-Lösung. Die Wahl fiel darauf, da es standardisierte Authentifizierungsverfahren  abbildet, rollenbasierte Zugriffe verwalten kann und ohne Eigenimplementierung eine robuste, sicherheitsfokussierte Benutzerverwaltung ermöglicht. Zusätzlich ist Keycloak opensource und bietet die Möglichkeit sämtliche Nutzerdaten zu verwalten und auch dementsprechend im System zu nutzen. Was eine komplexe Implementierung dieser Funktionen umgeht und das Entwicklerteam entlastet.
    \item \textbf{\textit{Docker}} wurde gewählt, um ein einheitliches und reproduzierbares Deployment sicherzustellen. Durch Containerisierung lassen sich Backend, Datenbanken und weitere Service unabhängig vom lokalen System konfigurieren und konsistent in Test-, Entwicklungs-, und Produktionsumgebung bereitstellen. 
\end{itemize}


\textbf{Begründete Gesamtentscheidung} \\
Die Auswahl der Technologien folgt dem Ziel, eine modular aufgebaute, skalierbare und wartbare Anwendung zu entwickeln. Node.js und Vue.js ermöglichen schnelle Entwicklung mit einer gemeinsamen Programmiersprache. PostgreSQL und Keycloak decken zentrale Anforderungen wie Datenpersistenz und Authentifizierung verlässlich ab. Docker sorgt dafür, dass das gesamte System sauber paketiert und portable ist, ohne Umgebungsabhängigkeiten oder Installationskonflikte. 

\newpage

% --- 6. Projektmanagement ---
\section{Projektmanagement}
\label{sec:projektmanagement}

Dieses Kapitel beschreibt die Methodik und die organisatorischen Aspekte, die für die Planung, Durchführung, Überwachung und Steuerung des Projekts zum Einsatz kommen.

\subsection{Projektmethodik}
\label{ssec:projektmethodik}
Aus dem Projektrahmen ging bereits hervor, dass wir im Team agil arbeiten sollen. Zudem entschieden wir uns für Scrum, da sich der Projektaufbau mit Meilensteinen gut für Sprints eignet. Da zu Projektbeginn auch nicht alle Requirements bekannt sind und die Aufwandschätzung nur ungenau erfolgt, ist eine iterative und inkrementelle Arbeitsweise sinnvoll.

\begin{itemize}
    \item \textbf{Sprints:} Die Entwicklung erfolgt in wöchentlichen Sprints.
    \item \textbf{Rollen:} Folgende Rollen sind definiert: Projektleiter, Product Owner, Scrum Master, Entwicklungsteam.

\end{itemize}

\subsection{Meetings}
In einem Sprint führen wir zuerst ein Sprint Planning durch, bei welchem wir Aufgaben verteilen. Diese werden in einem Weekly dann erneut abgeglichen, bei Fehleinschätzung des Aufwands eventuell nochmal umverteilt und letztendlich fertig bearbeitet. Zuletzt führen wir nach jedem Sprint eine kurze Retrospektive durch, welche dann in das nächste Sprint Planning übergeht. Abseits des Sprintkreises halten wir jede Woche (bei Bedarf) ein Treffen mit unserem Betreuer Michael Watzko ab, mit dem wir eventuelle Fragen abklären. Wir verzichten somit auf Daily Meetings, da für sie der Aufgabenumfang zu gering ist und wir sie im Rahmen eines Studienprojekts zeitlich für nicht angemessen erachten. 

\subsection{Teamorganisation und Verantwortlichkeiten}
\label{ssec:teamorganisation}
Das Projektteam besteht aus 3 Mitgliedern mit folgenden Hauptverantwortlichkeiten:
\begin{itemize}
    \item \textbf{Projektleiter:} Tobias Wahl, verantwortlich für die Gesamtkoordination und Stakeholder-Kommunikation.
    \item \textbf{Product Owner:} Yannick Schilling, verantwortlich für die Produktvision und die Priorisierung der Anforderungen.
    \item \textbf{Scrum Master:} Jonathan Müller, verantwortlich für die Einhaltung des Scrum-Prozesses und die Beseitigung von Hindernissen.
    \item \textbf{Entwicklungsteam:} Bestehend aus 3 Entwicklern, verantwortlich für die Implementierung der Funktionalitäten.
\end{itemize}

Die Rollenverteilung wurde im Team besprochen und entspricht den Stärken die wir zu Beginn des Projektes mitbringen. Zwar sind wir primär alle Entwickler, eine grobe Aufgabenverteilung hilft jedoch uns bei eventuell auftretenden Problemen schneller zu Orientieren.

\subsection{Aufgabenverteilung während der Entwicklungsphase}
Die Aufgabenverteilung war schon zu Beginn des Projektes relativ klar und übersichtlich.\\
Tobias konnte mit seiner Erfahrung im Webdesign die Hauptverantwortung für das Frontend übernehmen und sich dort gestalterisch ausleben. Er entwarf sowohl UI Sketches als auch einen Figma Clickdummy, an welchen er später das Design anlehnte.
Yannick war schon zu Beginn des Projektes sicher im Umgang mit Linux-Geräten und konnte sich schnell in verschiedene Technologien einarbeiten, wodurch er zu Beginn die Rolle eines Software-Architekten übernahm und in der Implementierungsphase die Schnittstellen zwischen Frontend, Backend und dem Raspberry klar definieren konnte. 
Jonathan übernahm im Team die Rolle als Scrum Master, überwachte die Aufgabenverteilung und implementierte die Layout-Datenbank. Zudem war er zuständig für jegliche UML-Diagramme, Datenmodelle und sonstige Verwaltungsaufgaben.
Neben der individuellen Aufgabenzuweisung, wie etwa der Unterstützung im Frontend durch Yannick und Jonathan oder der Datenbankoptimierung durch Yannick und Tobias, oblagen organisatorische und administrative Bereiche der gesamten Gruppe. Sowohl die Dokumentation und die Vorbereitung von Präsentationen als auch die Korrespondenz mit den Stakeholdern erfolgten kollaborativ.



\subsection{Tools und Prozesse}
\label{ssec:tools_prozesse}
Für das Projektmanagement und die Entwicklung werden folgende Tools und Prozesse eingesetzt:
\begin{itemize}
    \item \textbf{Anforderungsmanagement:} \textit{Jira} zur Erfassung und Verwaltung von User Stories, Requirements und Tasks.
    \item \textbf{Versionskontrolle:} \textit{Git} (mit \textit{GitHub}) für die Quellcodeverwaltung.
    \item \textbf{Kommunikation:} \textit{Discord} für die interne Teamkommunikation, \textit{WebEx} und Email zur Kommunikation mit Stakeholdern.
\end{itemize}

Mit den von uns gewählten Tools sind wir teils schon aus vergangenen Projekten vertraut, so fällt uns ihre Benutzung leichter. Die Funktionalitäten sind für unsere Anforderungen mehr als ausreichend.

\subsection{Jira}
Auf Jira wollen wir die einzelnen Aufgaben in Sprints einteilen und sie über das Board (Abb 16) als „ToDo“, „In Progress“, „in Review“ (für Code) oder „Done“ kennzeichnen.
Die Aufgaben im aktuellen Sprint werden einer oder mehreren Personen zugeteilt und es wird eine Gewichtung vorgenommen. So ist schnell einsehbar, wer woran arbeitet bzw. arbeiten sollte.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{Jira_board.png} 
    \caption{Jira Board}
    \label{fig:ui_selection}
\end{figure}
Zudem werden alle uns vorgegebenen Meilensteine (Abb 17) auf Jira eingetragen und mit den uns bekannten Aufgaben versehen. So können wir schon vor Erstellung des aktuellen/nächsten Sprints abschätzen, wie viel Aufwand vor uns liegt und stellen sicher, dass zukünftige Aufgaben nicht vergessen werden. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{meilensteine.png} 
    \caption{Meilensteine}
    \label{fig:ui_selection}
\end{figure}

Jede in Jira eingetragene Aufgabe versehen wir mit Acceptance Criteria (Abb 18), welche vor Fertigstellung der Aufgabe abgehakt werden müssen.
Dies geschieht um die Qualität der Features zu garantieren und uns vor dem Vergessen eventueller Unterpunkte zu schützen. Ein Feature gilt als abgeschlossen, sobald alle Acceptance Criteria erfüllt sind.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{Acceptance criteria.png} 
    \caption{Acceptance Criteria}
    \label{fig:ui_selection}
\end{figure}

Zusätzlich ist noch geplant die Traceability (Nachvollziehbarkeit) im Entwicklungsprozess
zu verbessern, indem eine Verknüpfung zwischen GitHub (Versionskontrolle) und Jira
(Ticket-System) hergestellt wird. Konkret wurde vorgeschlagen, Jira-Tickets direkt über Commit-
Nachrichten in GitHub zu schließen, um die Nachverfolgung von Änderungen und den Fortschritt
von Aufgaben transparent zu machen.

\newpage

% --- 7. Aufwandsschätzung ---
\section{Aufwandsschätzung}
\label{sec:aufwandsschaetzung}

Dieses Kapitel präsentiert die detaillierte Aufwandsschätzung für die Entwicklung. Die Schätzung basiert auf der Analyse des geforderten Funktionsumfangs und berücksichtigt die Komplexität, Herausforderungen und Risiken.

\subsection{Schätzmethodik}
\label{ssec:schaetzmethodik}
Die Aufwandsschätzung wurde mittels der \textit{Planning Poker}-Methode durchgeführt. Wir haben uns aufgrund des begrenzten Zeitfensters entschieden in Stunden zu schätzen. Sie bewegen sich auch im ungefähren Rahmen des bereits vorgegebenen Zeitaufwands.

\subsection{Detaillierte Schätzung pro Modul/Funktionalität}
\label{ssec:detaillierte_schaetzung}
Die folgende Tabelle und das Diagramm (Abb 32), geben einen Überblick über die geschätzten Aufwände.

\begin{table}[H]
    \centering
    \caption{Aufwandsschätzung pro Modul}
    
    \begin{tabularx}{\textwidth}{l l X}
        \toprule
        \textbf{Modul/Funktionalität} & \textbf{Geschätzter Aufwand} & \textbf{Kommentar} \\
        \midrule
        Benutzerverwaltung & 70h & KeyCloak Einbindung, Profilverwaltung. \\
        Datenmanagement & 70h & Datenbank, KeyCloak, Schnittstellen. \\
        UI Entwicklung (gesamt) & 160h & Basierend auf den Mockups und Usability-Anforderungen. \\
        Berichterstattung & 90h & Erstellung von Dokumentation. \\
        Architektur/Infrastruktur & 30h & Initiales Setup. \\
        Testing (gesamt) & 40h & Unit-, Integrations- und Akzeptanztests. \\
        Projektmanagement & 130h & Overhead für Meetings, Koordination, Seminare. \\
        \midrule
        \textbf{Gesamtaufwand (geschätzt)} & \textbf{590h} (ohne Puffer) & \\
        \bottomrule
    \end{tabularx}
\end{table}
\label{tab:aufwandsschaetzung_fix3}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{stundendiagramm.png} 
    \caption{Stundenverteilung}
    \label{fig:hours}
\end{figure}

\subsection{Risiken und Puffer}
\label{ssec:risiken_puffer}
Bei der Aufwandsschätzung wurden folgende potenzielle Risiken berücksichtigt und zusätzlich ein entsprechender Puffer eingeplant:
\begin{itemize}
    \item \textbf{Integration mit externen Systemen:} Unvorhergesehene Komplexitäten bei der Einbindung des SSO-Systems Keycloak. 10\%
    
    \item \textbf{Anforderungsänderungen:} Agiles Vorgehen reduziert dieses Risiko, aber ein kleiner Puffer für unvorhergesehene Änderungen ist eingeplant, da die Erfahrung mit den genutzten Technologien begrenzt ist. 5\% 
    
    \item \textbf{Einarbeitung:} Ein gewisser Puffer für Einarbeitungszeiten in neue Technologien. 10\%

    
\end{itemize}


\newpage
\section{Model-Views}
Eine große Hilfe beim Entwickeln einer Softwareanwendung ist eine strukturelle Sicht des Aufbaus sowie deren Verhalten. Hierzu sind im Folgenden sowohl die Struktur in Form eines UML-Klassendiagramms dargestellt als auch das entsprechende Verhalten in Form eines Sequenzdiagramms.

\subsection{Struktursicht}
 \\

Das in Abb. \ref{fig:classdiagramm} gezeigte Klassendiagramm bietet einen Überblick über den strukturellen Aufbau der Applikation. Zu sehen sind die Klassen User und die davon abgeleitete Klasse Admin, deren Instanzen von der Klasse Authentication initialisiert und mit Nutzerdaten gefüttert werden. \\

Der User hat hierbei Zugriff auf die Klasse Layout, welche sich aus den Datentypen  TextData, ImageData und QRData zusammensetzt. Die Attribute für Größe und Position der Daten sind im Interface Idata vorhanden. \\

Der Admin erhält zusätzlichen Zugriff auf einen Layout-Editor. Dieser hat über die Klasse Tools die Möglichkeit, Daten auf einem Layout zu platzieren und bearbeiten. Jedes platzierbare Element ist als Tool gespeichert. Gespeicherte Layouts werden dem User angezeigt und können mit der Funktion sendLayout an das ePaper geschickt werden.\\

\textbf{An dieser Stelle ist anzumerken, dass sämtliche Nutzerdaten mit Ihren Attributen in Keycloak und dessen Admin-UI verwaltet werden und mittels JWT-Token an die Anwendung übergeben werden können.}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{Struktursicht.png} 
    \caption{Klassendiagramm}
    \label{fig:classdiagramm}
\end{figure}

\newpage

\subsection{Verhaltenssicht}

Um sich das Verhalten der Anwendung genauer vorstellen zu können bieten sich Verhaltensdiagramme an, welche besondere Abläufe beschreiben. Hierzu wurde ein Sequenzdiagramm (Abb 34) erstellt, welches exemplarisch den Ablauf des sendens eines Layouts darstellt. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{Verhaltenssicht.png} 
    \caption{Sequenzdiagramm}
    \label{fig:sequencediagram}
\end{figure}

Die Sequenz beginnt mit einem Nutzer, der in der Anwendung auf die Layoutübersicht navigiert. Das Frontend holt sich dann über das Backend die Layoutdaten aus der Datenbank, welche es dem User dann präsentiert. Dieser entscheidet sich dann für ein Layout, welches er senden möchte. Das Layout wird schließlich an das ePaper weitergeleitet. \\

Da dieses Diagramm bereits alle Akteure und Komponenten des Systems (bis auf Keycloak) darstellt und alle weiteren möglichen Verhaltensmuster diesem weitgehend gleichen, genügt diese Ansicht, um ein Bild vom Verhalten der Anwendung zu erlangen. 

\newpage
\section{Datenbank}
Der folgende Abschnitt erläutert die zugrundeliegenden Datenmodelle und beschreibt den Datenfluss sowie die Interaktionen zwischen den Systemkomponenten.
\subsection{Datenmodelle}
Da die Applikation Daten aus mehreren Datenbanken bezieht, ist es wichtig ein Verständnis darüber zu erlangen, wie diese gespeichert sind. Hierzu wurden ein logisches und ein physisches Datenmodell angelegt. 
\subsubsection{logisches Datenmodell}

Aus diesem Modell (Abb 35) gehen die für die Speicherung der Daten notwendigen Tables und deren Atrribute hervor. Alle Nutzerdaten werden im Table User gespeichert (Admins gelten als Nutzer mit Is Admin = True), Layouts mit Metadaten im Table Layout, und deren Elemente mit Position und Größe im Table Elemente. Wichtig ist hierbei das Feld URI im Table Elemente, welches gesetzt wird, wenn das Element vom Typ Bild oder QR Code ist. Im Falle eines Bildes verweist es auf ein im Anwendungsordner gespeichertes Bild, im Falle eines QR Codes ist die URI die des Codes selbst. In allen weiteren Fällen gibt das Attribut Typ den genauen Typ des Elements an, z.B. Nachname oder Firma.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{Logisches.png} 
    \caption{logisches Datenmodell}
    \label{fig:logical}
\end{figure}

\newpage


\subsubsection{Physisches Datenmodell}

Es gehen genaue Verbindungen zwischen den Tables hervor (siehe Abb 36), wie Foreign oder Private Keys. Auch anzumerken ist die Begrenzung der meisten Textfelder auf 30 Zeichen durch VarChar(30), da Userdaten aus Platzgründen auf dem ePaper nicht unendlich lang sein dürfen und die meisten anderen Felder auch nicht mehr Speicherplatz einnehmen werden. So kann auch eine gültige Eingabe kontrolliert werden. Als Ausnahme gelten URIs, die nicht beschränkt werden. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{Physisches.png} 
    \caption{physisches Datenmodell}
    \label{fig:physical}
\end{figure}

\subsection{Umsetzung der Datenmodelle}
Da während der Implementierung klar wurde, dass sich mit dem oben gezeigten Datenmodell nicht alle Features zufriedenstellend umsetzen lassen, wurden sporadisch noch kleinere Änderungen vorgenommen. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{daten_final.png} 
    \caption{Finales physisches Datenmodell}
    \label{fig:physical_final}
\end{figure}

Wie in Abb. 37 zu sehen, sind viele Userattribute aus dem Modell gestrichen worden, da bei zu großer Menge an Attributen der Admin dazu verleitet wird zu viele auf ein Layout hinzuzufügen. Dies würde dazu führen, dass das Layout zu detailreich wird und auf dem Epaper damit unleserlich ist.
Zudem erhielt der Table Layouts ein zusätzliches Attribut \textit{Name}. Mit diesem lässt sich ein Layout benennen, was die Kommunikation der Nutzer über die Applikation erleichtert. Zusätzlich wird BackgroundColor gespeichert, um beim Abruf der Previews die korrekte Hintergrundfarbe zu haben.
Der Table Elements wurde durch die Attribute \textit{Source} und \textit{Style} erweitert. 
Das Source Element definiert ob ein Element dynamisch veränderbar ist, also sich an Nutzerinformationen anpasst (z.B. E-Mail), oder statisch ist (z.B. ein Dreieck). Diese Unterscheidung ist essenziell für die Implementierung des Layout-Editors.
Das Style Element hingegen gibt an welche Farbe ein Element besitzt, also ob es weiß oder schwarz ist. Durch die Implementierung als json können in Zukunft noch mehrere Style-Varianten hinzugefügt werden, was unserem Ziel die Anwendung skalierbar zu gestalten entgegenkommt. 
Der generelle Aufbau des Datenmodells hat sich als sinnvoll erwiesen und auch die Auslagerung der Userdaten an die Keycloak Datenbank war problemlos und hilfreich.


\newpage

\subsection{Datenfluss}

Der Aufbau des API Servers folgt dem Prinzip Seperation of Concerns, da die tatsächliche Abhandlung der Anfragen in einem dafür zuständigen Service geschieht. Zusätzlich dient er auch als Controller gemäß dem Model-View-Controller Prinzip. Der im Query Model definierte Connection Pool erlaubt einfaches Horizontales Scaling der Anwendung, da er mit mehreren laufenden Datenbank Servern verbunden werden kann.
\subsubsection{API-Service (Frontend)}
Implementiert die API-Aufrufe (Fetches), um Daten vom Backend zu laden und zu speichern.
\subsubsection{Query-Model:}
Definiert die zulässigen Datenbankabfragen, die vom Backend ausgeführt werden können. Die Queries sind fest im Backend hinterlegt und nutzen Platzhalter für variable Werte. Dies erzwingt die Trennung von Code und Daten (Prepared Statements), wodurch SQL-Injection effektiv verhindert wird. Der API-Service nutzt diese Definitionen, um validierte Parameter aus dem Frontend an die Datenbank zu übergeben.
\subsubsection{Layout-Service:}
Formatiert die von der Datenbank bereitgestellten Ressourcen als Layout bevor sie vom API Server an das Frontend weitergegeben werden.

\newpage

\section{API-Dokumentation}
Die Systemschnittstelle (API) bildet die zentrale Brücke zwischen dem Verwaltungs-Frontend, der Datenbank und der Hardware-Steuerung des Raspberry Pi. Die API ist in zwei Hauptmodule unterteilt: das \textit{Layout-Management} zur Verwaltung der Display-Inhalte und die \textit{Geräte-Steuerung} zur direkten Interaktion mit der Anzeige-Hardware.

\subsection{System-Architektur}
Das folgende Diagramm (Abb 38) illustriert den Datenfluss vom Client durch die protect Middleware zu den darunterliegenden Services bzw. der darunterliegenden Hardware.


\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{api_overview.png} 
    \caption{Übersicht API}
    \label{fig:api_overview}
\end{figure}

\subsubsection{Endpunkte: Layout-Management}
Diese Endpunkte steuern den Lebenszyklus der Anzeige-Layouts und der darin enthaltenen UI-Elemente.

\begin{table}[ht]
\centering
\small
\begin{tabularx}{\textwidth}{@{} llXl @{}}
\toprule
\textbf{Methode} & \textbf{Endpunkt} & \textbf{Beschreibung} & \textbf{Auth} \\ \midrule
\texttt{GET}    & \texttt{/layout-management/layouts} & Ruft eine Liste aller gespeicherten Layouts ab. & Ja \\
\texttt{POST}   & \texttt{/layout-management/layouts} & Erstellt ein neues Layout inkl. aller Elemente. & Ja \\
\texttt{PUT}    & \texttt{/layout-management/layouts/:id} & Aktualisiert ein Layout und ersetzt dessen Elemente. & Ja \\
\texttt{DELETE} & \texttt{/layout-management/layouts/:id} & Löscht ein Layout und die zugehörigen Elemente. & Ja \\ \bottomrule
\end{tabularx}
\caption{Übersicht der Endpunkte für das Layout-Management}
\end{table}

\noindent \textbf{Datenstruktur:} \\
Layout-Anfragen erwarten einen JSON-Body mit einem Namen und einem Array von Elementen. Ein Beispiel für eine \texttt{POST} Anfrage ist im folgenden Sequenz-Diagramm dargestellt:



\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{layout_sequence.png} 
    \caption{Sequenz-Diagramm Layout Erstellung}
    \label{fig:layout_sequence}
\end{figure}

\subsubsection{Endpunkte: Geräte-Steuerung}
Diese Routen kommunizieren direkt mit dem \texttt{RaspberryService}, um den Status der Hardware zu prüfen und die Anzeige zu aktualisieren.

\begin{table}[ht]
\centering
\small
\begin{tabularx}{\textwidth}{@{} llXl @{}}
\toprule
\textbf{Methode} & \textbf{Endpunkt} & \textbf{Beschreibung} & \textbf{Auth} \\ \midrule
\texttt{GET}    & \texttt{/device/status} & Prüft, ob der Raspberry Pi online und bereit ist. & Nein \\
\texttt{POST}   & \texttt{/display/upload} & Überträgt binäre Bilddaten direkt an das Display. & Nein \\ \bottomrule
\end{tabularx}
\caption{Übersicht der Endpunkte für die Geräte-Steuerung}
\end{table}

\noindent \textbf{Verarbeitung binärer Daten:} \\
Der Endpunkt \texttt{/display/upload} nutzt die \texttt{express.raw}-Middleware. Er erwartet den Content-Type \texttt{application/octet-stream} und unterstützt eine maximale Dateigröße von 10 MB. Im folgenden Sequenz-Diagramm ist der Ablauf dargestellt.


\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{rasp_sequence.png} 
    \caption{Sequenz-Diagramm Layout an Display}
    \label{fig:rasp_sequence}
\end{figure}

\subsubsection{Antwort- und Fehlercodes}
Die API nutzt standardisierte HTTP-Statuscodes, um über den Erfolg einer Operation zu informieren:

\begin{itemize}
    \item \textbf{200 OK / 201 Created:} Die Anfrage wurde erfolgreich verarbeitet.
    \item \textbf{400 Bad Request:} Validierungsfehler (z. B. fehlende Bilddaten beim Upload).
    \item \textbf{401 Unauthorized:} Der Keycloak-Token fehlt, ist abgelaufen oder ungültig.
    \item \textbf{500 Internal Server Error:} Ein unerwarteter Fehler in der Datenbank oder im Service.
    \item \textbf{503 Service Unavailable:} Der Raspberry Pi ist aktuell nicht erreichbar.
\end{itemize}

\subsection{Interaktive API-Dokumentation (Swagger-UI)}
Anstatt eine statische, manuelle API-Dokumentation zu pflegen, die schnell veraltet und fehleranfällig ist, haben wir uns für einen \textit{Code-First} Ansatz mit Swagger UI entschieden. Die Dokumentation wird dabei automatisch direkt aus den Kommentaren im Quellcode \textit{api-routes.js} generiert.

Dieser Ansatz bietet entscheidende Vorteile:\\

\begin{itemize}
    \item \textbf{Aktualität und Konsistenz:} Die Dokumentation ist immer synchron mit dem tatsächlichen Code. Jede Änderung an einem API-Endpunkt wird direkt in den Kommentaren daneben nachgeführt, wodurch die Dokumentation nie veraltet. 
    \item \textbf{Interaktivität:} Entwickler können die API-Endpunkte direkt im Browser testen, ohne zusätzliche Werkzeuge verwenden zu müssen. Dies beschleunigt die Entwicklung und das Debugging erheblich.
    \item \textbf{Effizienz: }Der Einarbeitungsaufwand für Entwickler wird drastisch reduziert, da die API selbsterklärend und direkt testbar ist.
    \item \textbf{Standardisierung: }Die generierte Dokumentation folgt dem etablierten OpenAPI-Standard.


\end{itemize}

Die technische Umsetzung erfolgt durch die Kombination der Node.js-Bibliotheken \textit{swagger-jsdoc}, welche die Kommentare im Code liest, und \textit{swagger-ui-express}, welche die interaktive Weboberfläche bereitstellt.

\subsubsection{Anleitung zur Benutzung}
Die interaktive API-Dokumentation ist ein zentrales Werkzeug, um die Funktionalität des Backends zu verstehen und zu testen.\\

\textbf{1. Aufrufen der Dokumentation}\\
Bei laufender Backend Anwendung im Browser zu folgender URL navigieren:\\
\textit{http://localhost:3000/api-docs}\\

\textbf{2. Authentifizierung (für geschützte Endpunkte)}\\
Unsere API verwendet Keycloak zur Absicherung bestimmter Endpunkte. Um diese testen zu können, muss man sich authentifizieren:

\begin{itemize}
\item Klick auf den Authorize-Button, der sich oben rechts auf der Seite befindet.
\item Ein Dialogfenster öffnet sich. Von Keycloak erhaltenen Bearer Token im Format Bearer <Ihr-Token> einfügen.
\item Nach der Bestätigung wird dieser Token automatisch bei allen Anfragen an geschützte Endpunkte (gekennzeichnet durch ein Schloss-Symbol) im Authorization-Header mitgesendet.

\end{itemize}

\textbf{3. Testen eines Endpunkts}
\begin{itemize}
\item \textbf{Auswählen: }Aufklappen des zu testenden Endpunktes (z. B. GET /protected). Eine Beschreibung ist sichtbar, die erwarteten Parameter und die möglichen Antworten.
\item \textbf{Aktivieren: }Klick auf den Button Try it out. Die Parameterfelder werden nun editierbar.
\item \textbf{Ausführen: }Ggf. erforderliche Parameter ausfüllen und auf Execute klicken
\item \textbf{Ergebnis analysieren: }Direkt darunter zeigt Swagger UI die Live-Antwort des Servers an, inklusive:
\begin{itemize}
\item Dem curl-Befehl, um die Anfrage zu reproduzieren.
\item Der genauen Anfrage-URL.
\item Dem HTTP-Statuscode (z.B. 200 OK oder 401 Unauthorized).
\item Dem Antwort-Body (z.B. die zurückgegebenen JSON-Daten).
\item Den Antwort-Headern.
\end{itemize}

\end{itemize}

Diese interaktive Umgebung ist das primäre Werkzeug zur Validierung und zum Testen der API-Funktionalität während der Entwicklung. Zusätzlich dient Sie als Beschreibung der Schnittstellen, welche parallel mit der Anwendung wächst und somit auch nach Projektabgabe weitergenutzt werden kann, ohne dass detaillierte Beschreibungen erforderlich sind.

\newpage

\section{Branching-Strategie und Entwicklungsstand}
Um die parallele Entwicklung der verschiedenen Systemkomponenten (Frontend, Backend, Datenbank) effizient zu koordinieren, wurde eine strukturierte Branching-Strategie auf Basis von Git implementiert. Die folgende Grafik (Abb 41) visualisiert den aktuellen groben Projektstatus (Stand 09.12.2025). Sie zeigt sowohl die bereits abgeschlossenen Integrationsschritte als auch die derzeit offenen Entwicklungszweige, an denen momentan gearbeitet wird. Es wurde darauf verzichtet, einzelne commits innerhalb der Hauptfeatures zu visualisieren, da dies zu unübersichtlich wäre.


\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{feature-timeline.png} 
    \caption{Aktueller Entwicklungsstand}
    \label{fig:physical}
\end{figure}

\subsection{Beschreibung des Workflows}

Der Git-Graph zeigt eine modifizierte Form des \glqq Gitflow\grqq-Workflows, der an die architektonische Trennung des Systems angepasst wurde.

\begin{enumerate}
    \item \textbf{Der Main-Branch (\texttt{main}):}\\
    Der \texttt{main}-Branch (Weiß/Grau) fungiert als stabile Basis (\glqq Single Source of Truth\grqq). Er enthält ausschließlich getesteten und integrierten Code.

    \item \textbf{Domänenspezifische Entwicklungszweige (DEV-Branches):}\\
    Zur Entkopplung der Teams existieren langlebige Zweige für die Hauptkomponenten:
    \begin{itemize}
        \item \textbf{\texttt{DEVui-designs} (Orange):} Sammelt alle Frontend-Implementierungen.
        \item \textbf{\texttt{DEVbackend} (Rot):} Dient als Integrationspunkt für Serverlogik und Hardware-Anbindung.
        \item \textbf{\texttt{DEVdatabase} (Lila):} Wurde für die initiale Datenmodellierung genutzt.
    \end{itemize}
\end{enumerate}

\subsection{Status Quo und offene Tasks}

\begin{itemize}
    \item \textbf{Frontend:} Die Features \texttt{feature/api-calls} (Anbindung der Services) und \texttt{feature/layout-editor} befinden sich noch in der Entwicklung, wie an den offenen Endpunkten der Linien zu erkennen ist.
    
    \item \textbf{Backend/Integration:} Der Branch \texttt{fix/fix-api-logic} ist aktuell ausgecheckt, um die API-Logik final an die Anforderungen des Frontends anzupassen.
\end{itemize}

Diese offenen Zweige werden erst nach Abschluss der Implementierung und erfolgreichem Review in die jeweiligen DEV-Branches und anschließend in den Main-Branch überführt.


\newpage

\section{Lizenzen und Abhängigkeiten}
\label{sec:dritt_lizenz}

Das System basiert auf einer Vielzahl von Open-Source-Bibliotheken. In diesem Abschnitt werden die wichtigsten Abhängigkeiten sowohl für das Backend als auch für das Frontend aufgeführt, inklusive der verwendeten Lizenzen (Stand der Entwicklung Januar 2026).

\subsection{Backend-Abhängigkeiten}
Das Backend basiert auf der Node.js-Laufzeitumgebung. Die folgende Tabelle gibt einen Überblick über die eingesetzten Module der serverseitigen Anwendung.

\begin{table}[ht]
\centering
\small
\begin{tabularx}{\textwidth}{@{} lllX @{}}
\toprule
\textbf{Paket} & \textbf{Version} & \textbf{Lizenz} & \textbf{Verwendungszweck} \\ \midrule
\texttt{express} & \^{}5.1.0 & MIT & Kern-Webframework für die REST-API. \\
\texttt{keycloak-connect} & \^{}26.1.1 & Apache-2.0 & Integration der Keycloak-Authentifizierung. \\
\texttt{pg-pool} & \^{}3.10.1 & MIT & Verwaltung der Datenbank-Verbindungen (PostgreSQL). \\
\texttt{cors} & \^{}2.8.5 & MIT & Verwaltung von Cross-Origin Resource Sharing. \\
\texttt{swagger-ui-express} & \^{}5.0.1 & Apache-2.0 & Bereitstellung der interaktiven API-Dokumentation. \\
\texttt{swagger-jsdoc} & \^{}6.2.8 & MIT & Generierung der OpenAPI-Spezifikation aus JSDoc. \\
\texttt{express-session} & \^{}1.18.2 & MIT & Sitzungsverwaltung für Web-Anfragen. \\ \bottomrule
\end{tabularx}
\caption{Übersicht der Backend-Abhängigkeiten}
\end{table}

\subsection{Frontend-Abhängigkeiten}
Das Frontend wurde mit dem Vue.js-Framework entwickelt. Die folgende Tabelle listet die Bibliotheken auf, die für die Benutzeroberfläche und den Layout-Editor entscheidend sind.

\begin{table}[ht]
\centering
\small
\begin{tabularx}{\textwidth}{@{} lllX @{}}
\toprule
\textbf{Paket} & \textbf{Version} & \textbf{Lizenz} & \textbf{Verwendungszweck} \\ \midrule
\texttt{vue} & \^{}3.5.22 & MIT & Basis-Framework für die reaktive Benutzeroberfläche. \\
\texttt{vue-router} & \^{}4.6.3 & MIT & Clientseitiges Routing innerhalb der Anwendung. \\
\texttt{keycloak-js} & \^{}26.2.1 & Apache-2.0 & Keycloak-Client für Authentifizierung im Browser. \\
\texttt{vue3-draggable-resizable} & \^{}1.6.5 & MIT & Kernkomponente für den visuellen Layout-Editor. \\
\texttt{html-to-image} & \^{}1.11.13 & MIT & Konvertierung von DOM-Elementen in Bilder für den Display-Upload. \\
\texttt{pica} & \^{}9.0.1 & MIT & Hochwertige Bildskalierung im Browser vor dem Upload. \\
\texttt{qrcode} & \^{}1.5.4 & MIT & Generierung QR-Code aus URL \\\bottomrule
\end{tabularx}
\caption{Übersicht der Frontend-Abhängigkeiten}
\end{table}

\noindent \textit{Hinweis: Alle aufgeführten Lizenzen erlauben die Verwendung im Rahmen dieses Projekts (Open-Source). Die vollständigen Lizenztexte sind in den jeweiligen \texttt{node\_modules}-Verzeichnissen der Installation hinterlegt.}

\newpage

\subsection{Projekt-Lizenz und Nutzungsrechte}
\label{sec:projekt_lizenz}

Bei der vorliegenden Software handelt es sich um eine Auftragsentwicklung. Es muss zwischen den verwendeten Drittanbieter-Bibliotheken (siehe Abschnitt \ref{sec:dritt_lizenz}) und dem spezifisch für dieses Projekt entwickelten Quellcode unterschieden werden. Drittanbieter-Bibliotheken bleiben von der folgenden Erklärung unberührt.

\subsubsection{Eigenentwicklung (Core-Logik)}
Der im Rahmen dieses Projekts erstellte Anwendungscode, insbesondere:
\begin{itemize}
    \item die Datenbank-Schemata und \texttt{layoutModel}-Logik,
    \item die Implementierung des \texttt{RaspberryService},
    \item sowie die Vue.js-Komponenten des Layout-Editors,
\end{itemize}
sind unter der MIT-Lizenz veröffentlicht.\\

Mit der Übergabe des Projekts an die uxitra GmbH wurden diese Komponenten als Open-Source-Software lizenziert. Dies gewährt der uxitra GmbH sowie jedwedem Dritten die vollständigen Nutzungs- und Verwertungsrechte (einschließlich Kopieren, Modifizieren und Verbreiten) gemäß den Bedingungen der MIT-Lizenz. Der vollständige Lizenztext befindet sich in der Datei LICENSE im Hauptverzeichnis des Repositories.

\section{Reflektion und Ausblick}

\subsection{Reflektion}
Während des Projektes musste sich das Team in verschiedene Technologien, Konzepte und Arbeitsweisen einarbeiten. 
So lernte das Team beispielsweise das Arbeiten mit verschiedenen Frameworks, den Umgang mit Endpunkten, Containerisierung, das Aufsetzen einer Entwicklungsumgebung und den Aufbau einer Fullstack Anwendung. 
Auch das parallele Arbeiten mit Git wurde während der Projektdauer verfestigt, da man zu Beginn noch zurückhaltend war zwei parallele Branches im Frontend oder Backend laufen zu lassen, um merge Konflikte um jeden Preis zu verhindern. Diese Angst verflog jedoch mit zunehmender Zeit, da die gefürchteten Probleme auch bei gleichzeitigem Arbeiten nicht auftraten.
Da nur 3 Entwickler im Team waren musste jeder Verantwortung für seine Aufgabenbereiche übernehmen und man lernte offene Aufgaben zeitlich einzuschätzen und abzuarbeiten. 
Durch das Entwickeln im Team übte man, sich gegenseitig neue Inhalte zu erklären und wurde so zum Teaminternen Experten für seinen Zuständigkeitsbereich. 
Die Kommunikation mit Kunde und Betreuer half bei der Unterscheidung verschiedener Stakeholder und welche Entwicklungen für diese von Relevanz sind. 
Das Projekt baute so nicht nur die technischen Fähigkeiten des Teams aus, sondern auch Softskills, die für die Softwareentwicklung unabdingbar sind.

\subsection{Ausblick}
Auch wenn die Anwendung den geforderten Funktionsrahmen erfüllt hat das Team, auch in Absprache mit dem Kunden und Betreuer, noch Ideen zu Erweiterung und Optimierung der Applikation, welche aus Zeitgründen wichtigeren Features weichen mussten. 
Die Anwendung ist aktuell funktionsfähig für Desktop Geräte wie Laptops und Workstations, die Bedienung auf Smartphones ist aufgrund der limitierten Bildschirmgröße aktuell jedoch nicht möglich. Durch ein Refactoring des Frontends wäre dieses Feature in der Zukunft jedoch generell möglich. 
Auch der Layouteditor kann auf verschiedene Weise erweitert werden. Eine Idee hierfür wäre die erweiterte Personalisierung der Textelemente (evtl. durch verschiedene Schriftarten) oder das Einfügen mehrerer Nutzerattribute/Formen. Zudem wäre es möglich das erstellte Layout nicht nur an das Epaper Display zu senden, sondern auf dem aktuellen Gerät herunterzuladen.






\newpage
\section{Anhang}


\subsection{Gesprächsprotokoll Kundentermin 1}
\begin{itemize}[leftmargin=3cm]
    \item \textbf{Datum:} 16. Oktober 2025
    \item \textbf{Uhrzeit:} 16:00 Uhr
    \item \textbf{Ort:} WebEX
\end{itemize}

\subsection*{Anwesende:}
\begin{itemize}
    \item \textbf{Entwicklungsteam:}
    \begin{itemize}
        \item Jonathan Müller
        \item Tobias Wahl
        \item Yannick Schilling
    \end{itemize}
    \item \textbf{Betreuer:}
    \begin{itemize}
        \item Michael Watzko (uxitra GmbH)
    \end{itemize}
    \item \textbf{Kunde:}
    \begin{itemize}
        \item Alexander Pärsch (uxitra GmbH)
    \end{itemize}
\end{itemize}

\subsection*{Thema des Gesprächs:}
Vorstellung der geplanten Inhalte des Projekts eVisitenkarte der uxitra GmbH im Rahmen des Studienprojekts SWMT.

\subsection*{Ablauf des Gesprächs:}
Nach einer kurzen Vorstellungsrunde stellte das Entwicklungsteam Herrn Pärsch die geplante Agenda und im Anschluss die ersten Inhalte des Projekts mittels einer Präsentation vor. Herr Pärsch hatte jederzeit die Möglichkeit, die Präsentation für Anmerkungen, Fragen und Feedback zu unterbrechen.

\subsection*{Vorgestellte Inhalte und Anmerkungen des Kunden:}

\subsubsection*{1. Vorstellungsrunde und Agenda}
\begin{itemize}
    \item \textbf{Vorgestellte Inhalte:}
    \begin{itemize}
        \item Kurze gegenseitige Vorstellung der Anwesenden.
        \item Aufzeigen der heutigen Agenda:
        \begin{itemize}
            \item Umfang und Anforderungen: User Stories, funktionale Anforderungen
            \item Visualisierung: UI-Sketches
            \item Prozess: Tools, Kommunikation
            \item Zeitplan und Meilensteine: Grobe Zeitplanung
        \end{itemize}
    \end{itemize}
    \item \textbf{Anmerkungen/Fragen/Feedback des Kunden:}
    \begin{itemize}
        \item Keine spezifischen Anmerkungen zur Agenda.
    \end{itemize}
\end{itemize}

\subsubsection*{2. Umfang und Anforderungen: User Stories, funktionale Anforderungen}
\begin{itemize}
    \item \textbf{Vorgestellte Inhalte :}
    \begin{itemize}
        \item User Stories
        \item Funktionale Anforderungen
    \end{itemize}
    \item \textbf{Anmerkungen/Fragen/Feedback des Kunden:}
    \begin{itemize}
        \item \textbf{Datenschutz (DSGVO):} Es wurde angeregt, die Aspekte der DSGVO bei der Verarbeitung und Speicherung von User-Daten zu berücksichtigen.
        \item \textbf{Userverwaltung:} Der Kunde schlug vor, die Userverwaltung möglicherweise direkt in \textbf{KeyCloak} zu implementieren/integrieren, um vorhandene Lösungen zu nutzen und den Aufwand zu minimieren.
        \item \textbf{Prüfung von User-Daten:} Die Möglichkeit eines Background-Tasks zur Prüfung von User-Daten (z.B. auf Aktualität oder Vollständigkeit) wurde als Idee eingebracht.
        \item \textbf{QR-Code für vCard:} Der Kunde erwähnte die Idee eines QR-Codes, der direkt eine vCard-Datei generiert oder beinhaltet, um den Austausch von Kontaktdaten zu erleichtern.
        \item \textbf{Tipps für die Zwischenpräsentation:} Herr Pärsch gab den Hinweis, dass bei der nächsten Präsentation der Fokus vor allem auf die \textbf{technische Umsetzbarkeit} gelegt werden sollte und man sich nicht zu viel versprechen sollte, was eventuell technisch nicht realisierbar ist.
    \end{itemize}
\end{itemize}

\subsubsection*{3. Visualisierung: UI-Sketches}
\begin{itemize}
    \item \textbf{Vorgestellte Inhalte:} 
    \item UI-Sketches
    \item Ideen für Designs und deren Umsetzung
    \item \textbf{Anmerkungen/Fragen/Feedback des Kunden:}
    \begin{itemize}
        \item \textbf{Begrenzte Feldgrößen:} Herr Pärsch schlug vor, die Begrenzung von Feldgrößen (z.B. Textfelder für Namen, Titel) in den UI-Sketches zu berücksichtigen, um Probleme mit zu langen Eingaben zu vermeiden.
        \item \textbf{Impersonierung (Admin als User):} Es wurde angeregt, die Möglichkeit zu schaffen, dass ein Administrator sich als normaler User ausgeben (impersonieren) kann, um Tests durchzuführen oder Support zu leisten.
        \item \textbf{Help-/Support-Button:} Die Integration eines klar sichtbaren Help- oder Support-Buttons im UI wurde vorgeschlagen, um Usern bei Fragen oder Problemen schnell Unterstützung zu bieten.
        \item \textbf{Systemkonzeption (Desktop vs. Mobile):} Eine wichtige Frage des Kunden war, für welches Endgerät das System primär konzipiert ist (Desktop oder Mobile), da dies Auswirkungen auf das UI-Design und die Usability hat.
    \end{itemize}
\end{itemize}

\subsubsection*{4. Prozess: Tools, Kommunikation}
\begin{itemize}
    \item \textbf{Vorgestellte Inhalte:} 
    \item Projektmanagement: Jira
    \item Versionskontrolle: github
    \item Kommunikationsmittel

    
    \item \textbf{Anmerkungen/Fragen/Feedback des Kunden:}
    \begin{itemize}
        \item \textbf{Traceability mit Jira:} Der Kunde gab den Tipp, die Traceability (Nachvollziehbarkeit) im Entwicklungsprozess zu verbessern, indem eine Verknüpfung zwischen GitHub (Versionskontrolle) und Jira (Ticket-System) hergestellt wird. Konkret wurde vorgeschlagen, Jira-Tickets direkt über Commit-Nachrichten in GitHub zu schließen, um die Nachverfolgung von Änderungen und den Fortschritt von Aufgaben transparent zu machen.
    \end{itemize}
\end{itemize}

\subsubsection*{5. Zeitplan und Meilensteine: Grobe Zeitplanung}
\begin{itemize}
    \item \textbf{Vorgestellte Inhalte:} 
    \item Vorbestimmte Meilenstein des Projekts
    \item \textbf{Anmerkungen/Fragen/Feedback des Kunden:}
    \begin{itemize}
        \item \textbf{Visuelle Timeline:} Der Kunde schlug vor, für die Zwischenpräsentation eine visuelle Zeitleiste (Timeline) zu erstellen. Diese sollte übersichtlich darstellen, was bisher im Projekt geschehen ist und welche Meilensteine und Schritte für die Zukunft geplant sind.
    \end{itemize}
\end{itemize}

\subsection*{Offene Punkte/Nächste Schritte:}
\begin{itemize}
    \item Das Entwicklungsteam prüft die technische Umsetzbarkeit der angesprochenen Punkte, insbesondere die Integration von KeyCloak und die DSGVO-Konformität.
    \item Das Team wird die Anmerkungen zu den User Stories, funktionalen Anforderungen, UI-Sketches (Feldgrößen, Impersonierung, Help-Button, Desktop/Mobile-Konzeption) und dem Prozess (Traceability Jira/GitHub) in die weitere Planung und Gestaltung einbeziehen.
    \item Für die nächste Präsentation: Fokus auf technische Machbarkeit und realistische Versprechen legen. Klärung der primären Plattform (Desktop/Mobile) für das System. Prüfung der Implementierung der Jira/GitHub-Verknüpfung. \textbf{Erstellung einer visuellen Timeline, die den bisherigen Fortschritt und die zukünftigen Meilensteine darstellt.}
\end{itemize}

\subsection*{Fazit des Gesprächs:}
Das Gespräch bot einen guten ersten Einblick in die geplanten Inhalte des Projekts und ermöglichte dem Kunden, frühzeitig wertvolles Feedback und wichtige Anregungen zu geben, die in die weitere Entwicklung einfließen werden.

\subsection*{Protokolliert von:}
Yannick Schilling

% --- Ende des Dokuments ---
\end{document}